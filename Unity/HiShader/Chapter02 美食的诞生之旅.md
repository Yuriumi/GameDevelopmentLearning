# 概览
- 了解渲染管线的相关概念以及Shader的基础知识
- 通过ShaderLab实现简单的顶点动画以及光照效果

---

# 基础概念-渲染管线
在**虚拟相机**,**三维物体**,**光源**,**照明模式**,**纹理**等诸多条件都给定的条件下,生成或是绘制一幅*二维图像*的过程.举例来说就是美食的制作过程
这个过程分为四个主要阶段
- 应用程序阶段
- 几何阶段
- 光栅化阶段
- 像素处理阶段
![渲染管线工作阶段](https://learning-cdn-public-prd.unitychina.cn/20220817/learn/images/914b6b3c-be32-43aa-860c-0934d9bd3caf_image.png.2000x0x1.webp)
## 应用程序阶段 （The Application Stage） CPU
负责数据的准备,为后续阶段提供所需的数据,如模型,贴图,光照,相机位置

---

## 几何阶段（The Geometry Stage） GPU

---

#### 图元
简单的理解为渲染管线中所有点,线,面的统称

### 顶点着色
==可编程==部分,逐个对==顶点相关信息==进行处理,生成[[Chapter02 美食的诞生之旅#图元|图元]],计算并==向下传递==,这个阶段主要是为了控制Mesh的*形态*
Shader中对应的是**VertxShader**,它的工作主要是计算**顶点的位置**,**法线**,**纹理坐标**,根据**材质**,**纹理**,以及**光源属性**进行顶点光照计算,常见的**顶点动画**在这里实现.
### 几何着色
**可选可编程**部分,并非所有GPU都支持,它可以把简单的[[Chapter02 美食的诞生之旅#图元|图元]]拓展成更复杂的形式,我们认为[[Chapter02 美食的诞生之旅#顶点着色|顶点着色]]和几何着色共同构成了几何阶段的可编程部分.
### 裁剪
对**顶点几何两大着色器**的输出结果进行处理,它会把完全处于**视锥体外**的几何部分*裁剪*掉,只留下玩家*可以看到*的部分,并对新生成的顶点进行插值,向下传递.

---

## 光栅化阶段（Rasterization） GPU

---
#### 片元
是光栅化之后产生的像素点，因为没有被画到屏幕上，不能被直接称为像素一个像素的最终结果可能是由多个片元来决定的，渲染管线为了细分，就单独创造了片元这个词来描述它，片元只是渲染管线的概念

#### 像素
最后写到图像上的*值*

### 屏幕映射
经过裁剪之后，硬件会通过**透视除法**将物体从**裁剪空间**变换为**标准化设备坐标**也叫[[NDC]]，之后GPU会把得到的NDC空间坐标下的顶点，*映射*到**屏幕空间坐标**中，进行图元装配，这一步会==计算微分==、==边方程==和==其他三角形数据==，*三角形的朝向剔除*就是在这个阶段完成的。
### 图元装配
主要是计算微分（differentials）、边方程（edge equations）和其他三角形数据（顶点属性插值）
![图元装配](https://learning-cdn-public-prd.unitychina.cn/20220817/learn/images/bf3476df-5af1-4579-b12d-f1bd13d72b31_image.png.2000x0x1.webp)
### 光栅化
它会在每个像素点上生成一个[[Chapter02 美食的诞生之旅#片元|片元]]，如果开启了==多重采样抗锯齿==，就会对每个[[Chapter02 美食的诞生之旅#像素|像素]]进行**多次采样**，产生多个片元，最终进行*混合*来达到抗锯齿的效果

## 像素处理阶段 （ Pixel Processing ）GPU

---

### 像素 (片元) 着色器
**可编程**部分，它的工作主要是根据==顶点的插值属性==，进行逐像素计算，因为它需要处理每一个像素，所以这也是*最耗时*的一个阶段。它的输入输出都是**片元数据**，输入的数据是**颜色**和**纹理坐标**，输出的则是计算后所得的每个像素的**色彩值**，像是**逐像素光照**、**反射**、**阴影**等等更为复杂的效果都是可以在这里实现的，这一步更像是再给我们的食材上色。
### 合并
*只可配置不可编程部分*，在一系列的**测试后**会进行合并，所谓的测试则是*判断一个像素点最终是否应该被显示在屏幕上*，通过测试的颜色会和**缓冲区**的颜色==叠加混合==

## 坐标空间
**模型空间**以物体本身为原点的坐标空间，**世界空间**以世界的(0,0)为原点的坐标空间，**视图空间**以相机为原点的坐标空间，描述的物体在相机的哪个位置,**裁剪空间**顶点坐标乘以MVP矩阵之后所在的空间，**屏幕空间**窗口屏幕上的二维像素坐标空间
![坐标空间](https://learning-cdn-public-prd.unitychina.cn/20220829/learn/images/7a0245e4-ad00-482a-b99d-8c5c28bc8a04_image.png.2000x0x1.webp)
# Shader
## 基础概念
Shader比较学术的百科回答就是用来==实现图像渲染的==，用来*替代***固定渲染管线的可编辑程序**。其中==Vertex Shader（顶点着色器）==主要负责顶点的几何关系等的运算，==Pixel Shader（像素着色器）==主要负责[[Chapter02 美食的诞生之旅#片元|片元]]颜色等的计算。
那说人话就是可以把渲染流程看作美食的制作流程，一般来说制作美食需要选食材，切菜，炒菜，加调料上色，出锅等流程。我们可以把模型的Mesh看作食材，而Shader在这个流程中主要==负责切菜和上色==的步骤，==切菜控制食材的形态，这就是顶点Shader负责的==，==加调料上色可以让美食变得更加秀色可餐，这也就是像素Shader负责的==
## Unity中的默认Shader类型
- **Standard Surface Shader**
标准表面着色器，它是一种**基于物理**的着色系统，可以理解为 它是通过对==物理现象的简单模拟==，可以实现生活中各种物品的效果，比如石头、木材、玻璃、塑料和金属等等。 ^64f3b1
- **Unlit Shader**
它是最简单的着色器，与[[Chapter02 美食的诞生之旅#^64f3b1|Standard Surface Shader]]相比，它去除了冗长的光照公式以及阴影解算，因此得名 Unlit，翻译过来就是无光照，也正因如此，它只由最基础的 **Vertex Shader** 和 **Fragment Shader** 组成，最为基础易懂。
- **Image Effect Shader**
它其实也是也是**顶点片元着色器**，不过它主要针对实现各种**屏幕后处理效果**，那后处理是什么呢？一般像是**泛光**、**调色**、**景深**、**模糊**等基于最终整个屏幕画面而进行再次处理的就是后处理，这里做个简单的了解即可。
- **Compute Shader**
计算着色器，它是在**GPU**中运行的一段程序，==独立于常规渲染管线之外的==，它可以==直接将GPU作为并行处理器加以利用==，从而==使GPU不仅具有3D渲染能力，还具有其他的运算能力==。一般会在**需要大量并行计算**的时候使用。
- **Ray Tracing Shader**
光线追踪着色器，光线追踪是指从摄像机出发的**若干条光线**，每条光线会和场景里的物体*求交*，根据交点位置**获取表面的材质**、**纹理**等信息，并==结合光源信息计算光照==。相对于传统的光栅化渲染，==光线追踪可以轻松模拟各种光学效果，如反射、折射、散射、色散等==。但由于在进行求交计算时需要知道==整个场景的信息==，它的计算**成本也是非常高**的。
## ShaderLab
Unity为我们**封装的着色器语言**，而目前主流的着色器语言有3种，==基于OpenGL的GLSL== / ==基于DX的HLSL== / ==NVIDIA公司的CG==。
==GLSL与HLSL分别是基于OpenGL和Direct3D的接口==，两者**不能混用**。而==CG则是为了使图形硬件的编程变得和C语言编程一样方便自由==，它本身*基于C语言*。但其实由于Microsoft和NVIDIA的相互协作，他们在标准硬件光照语言的语法和语义上达成了一致，所以HLSL和Cg其实**可以看为是同一种语言。**
而ShaderLab则是Unity在HLSL和CG的基础之上封装的**只属于Unity的着色器语言**，它的**灵活性更高**，而且不再需要将 Shader 的配置 硬写在引擎代码中，本质是**在底层着色语言的基础上，额外提供了声明信息，以数据驱动的方式**使我们在渲染管线内**自由发挥**。
## 实战案例
![UnlitShader](https://learning-cdn-public-prd.unitychina.cn/20220817/learn/images/0d4fd6f4-6eeb-4e27-8920-66e90cdf65f3_image.png.2000x0x1.webp)
UnlitShader默认是**不受光**的材质，纹理什么颜色它就**直接显示**出来了，但通常来说，光照是三维世界**不可或缺**的部分，现实世界中，当光照射到物体表面时, 物体对光会发生*反射*、*透射*、*吸收*、*折射*等==被物体反射的光进入视觉系统==，使看见物体的表面有明暗之分，为了模拟这一现象，科研家建立了一些数学模型来替代复杂的物理模型，统称为**光照模型**。
![光照模型](https://learning-cdn-public-prd.unitychina.cn/20220817/learn/images/f63d5f5b-c724-43c7-b376-cd34d9b11f01_image.png.2000x0x1.webp)
比较常见的光照模型有漫反射的 Half Lambert 模型 ，以及镜面反射的 Blinn-Phong 模型。 Half Lambert 能够较好地表现粗糙表面上的光照现象，像如石灰墙，纸张等等，但是在渲染金属材质制成的物体时，则会显得呆板，表现不出光泽。主要原因是其没有考虑到镜面反射效果，所以 Blinn-Phong 对其进行了很好的补充。
![](https://learning-cdn-public-prd.unitychina.cn/20220817/learn/images/e43e44c9-b3ff-4faf-bb9e-bfd634e43f7f_image.png.2000x0x1.webp)
![](https://learning-cdn-public-prd.unitychina.cn/20220817/learn/images/b01c5657-c339-44d9-8895-b12a62297e99_image.png.2000x0x1.webp)
